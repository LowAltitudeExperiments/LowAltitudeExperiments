import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
import matplotlib.pyplot as plt
import math
from pathlib import Path

RE=6378


from pathlib import Path
datasets = {
    "10 km": {
        "folder": "/home/caterina/work/PIRATA/cosmique_proton_generator/cosmic_proton_shower_simulator/TEST_PIRATA/below_limb/below_generated_configs_100PeV/output_npz/",
        "optical_axis": 86.79122,
    },
    "20 km": {
        "folder": "/home/caterina/work/PIRATA/cosmique_proton_generator/cosmic_proton_shower_simulator/TEST_PIRATA/below_limb/below_generated_configs_20_100PeV/output_npz/",
        "optical_axis": 85.467693,
    },
    "30 km": {
        "folder": "/home/caterina/work/PIRATA/cosmique_proton_generator/cosmic_proton_shower_simulator/TEST_PIRATA/below_limb/below_generated_configs_30_100PeV/output_npz/",
        "optical_axis": 84.453558,
    }
}

emer_angles=[2.02169133e-03, 1.80986219e-03, 1.64989844e-03, 1.23674768e-03,
             1.02298836e-03, 8.38838978e-04, 6.50581475e-04, 5.07186554e-04,
             3.92577600e-04, 3.18449487e-04, 2.45138649e-04, 1.98058350e-04,
             1.69064517e-04, 1.45671753e-04, 1.16596352e-04, 1.03982740e-04,
             8.69033411e-05 ,7.52353981e-05, 6.46191114e-05, 5.49691906e-05,
             4.71997205e-05, 3.99570455e-05, 3.66770393e-05, 3.02926141e-05,
             2.56558095e-05, 2.20945082e-05, 1.90275537e-05, 1.66590946e-05,
             1.46538173e-05, 1.28899179e-05, 1.11854525e-05, 9.68366193e-06,
             8.38350604e-06, 7.59581015e-06, 6.90704198e-06 ,6.28072949e-06,6.00000000e-6,5.00000000e-6,4.00000000e-6,3.00000000e-6,0.000000000,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,0.00000000e-10,]
#emer_angles=[7.99948803e-03, 8.29103468e-03, 7.12485245e-03, 3.79738989e-03,
#             2.50209829e-03, 1.84236064e-03, 1.04249612e-03, 5.86697490e-04,
#             4.13234167e-04, 2.94626673e-04, 2.11069965e-04, 1.56285039e-04     #        , 1.28641448e-04, 1.01768380e-04, 7.97032663e-05, 6.85135897e-05            ,5.75751966e-05, 4.29792049e-05, 3.74957206e-05, 3.15970863e-05,
 #            2.64134525e-05, 2.25979629e-05, 1.93336303e-05, 1.66814835e-05,
 #             1.44991144e-05, 1.25767417e-05, 1.01849321e-05, 8.24799019e-06,
 #            7.25545810e-06, 6.88568663e-06, 1.00000000e-10]

 
# Aggiungo l'altitudine (h) estratta dalla chiave ("10 km" -> 10)
for key in datasets:
    datasets[key]["altitude"] = int(key.split()[0])
for key, value in datasets.items():
    folder_path = Path(value["folder"])
    # Prendi solo i file .npz e ordina alfabeticamente (opzionale)
    files = sorted([f.name for f in folder_path.glob("*.npz")])
    datasets[key]["files"] = files

# === Colori per ogni distanza nel plot ===
colors = {
    "10 km": "royalblue",
    "20 km": "darkorange",
    "30 km": "green"
}

fig, ax = plt.subplots(figsize=(9,6))
# === Ciclo su ciascun dataset ===
for label, info in datasets.items():
    folder = info["folder"]
    optical_axis = info["optical_axis"]
    h = info["altitude"]  # altezza in km

    file_list = info["files"]
    counts_list = []
    angles = []

    for filename in file_list:
        path = os.path.join(folder, filename)
        try:
            data = np.load(path)
            counts = data["dist_counts"]
            base_name = os.path.splitext(filename)[0]

            # Estrae l'angolo come float: "output_86_25" -> 86.25
            suffix = base_name.split("_")[-2] + "." + base_name.split("_")[-1]
            angle = float(suffix)

            if angle < 100.: #optical_axis: #> for above
                angles.append(angle)
                counts_list.append(counts[0])  # Considera solo il primo histogram

        except Exception as e:
            print(f"❌ Errore nel file {path}: {e}")

    # Ordina gli angoli e i conteggi corrispondenti
    if angles:
        sorted_data = sorted(zip(angles, counts_list))
        sorted_angles, sorted_counts = zip(*sorted_data)


        sorted_counts = np.array(sorted_counts)
        theta_sh_rad = np.radians(sorted_angles)
        
        # Troncamento emer_angles alla stessa lunghezza
        emer_angles_cut = emer_angles[:len(sorted_counts)]
        
        # Moltiplicazione
        weighted_counts = sorted_counts #* emer_angles_cut
        
        # Converto theta_sh in radianti
        
        # Calcolo theta_d in radianti usando la formula:
        valore = (RE / (RE + h)) * np.cos(theta_sh_rad)
        # Clampo il valore per evitare errori arcsin fuori dominio

        valore = np.clip(valore, -1, 1)
        theta_d_rad = np.arcsin(valore)
        
        # Converto theta_d in gradi
        theta_d_deg = np.degrees(theta_d_rad)
        sorted_angles = np.array(theta_d_deg)

        # Plot o ulteriori operazioni
        plt.plot(sorted_angles, weighted_counts, label="Cherenkov " + label, color=colors[label], linewidth=3)
#    plt.plot(sorted_angles, emer_angles, label="emergence probability ",marker='x',markersize=10, linewidth=0)
        # Traccia la retta verticale dell’optical axis
    plt.axvline(optical_axis, color=colors[label], label="Limb-viewing angle " + label,linestyle=':', linewidth=2,alpha=0.7)

# Caricamento del file .h5
store = pd.HDFStore('altitude-and-angle-scan-extended.h5')
df_30_above = store['below_30km']
df_20_above = store['below_20km']
df_10_above = store['below_10km']
store.close()


#overall_flux = (df_36_above.band0_rx + df_36_above.band1_rx + df_36_above.band2_rx) / df_36_above.area0_m2
# Calcolo del flusso complessivo per ciascun DataFrame
def compute_overall_flux(df):
    return (df.band0_rx + df.band1_rx + df.band2_rx) / df.area0_m2
if df_30_above.theta_deg.all()<100.:
    flux_30 = compute_overall_flux(df_30_above)
if df_20_above.theta_deg.all()<100.:
    flux_20 = compute_overall_flux(df_20_above)
if df_10_above.theta_deg.all()<100.:
    flux_10 = compute_overall_flux(df_10_above)


print(df_20_above.theta_deg)
desired_angles = np.arange(0, 65., 0.1)  # Include 65
# Selezione e ordinamento

df_30_sel = df_30_above[np.round(df_30_above.theta_deg, 1).isin(desired_angles)]
df_20_sel = df_20_above[np.round(df_20_above.theta_deg, 1).isin(desired_angles)]
df_10_sel = df_10_above[np.round(df_10_above.theta_deg, 1).isin(desired_angles)]
# Verifiche
#assert len(df_30_sel) == 60, f"Attesi 50 angoli interi, trovati {len(df_30_sel)}"
#assert len(df_20_sel) == 56, f"Attesi 50 angoli interi, trovati {len(df_20_sel)}"
#assert len(df_10_sel) == 56, f"Attesi 50 angoli interi, trovati {len(df_10_sel)}"


# Calcola flusso
#flux_30 = compute_overall_flux(df_30_sel)

# Moltiplica per emer_angles
#weighted_flux_30 = flux_30.to_numpy() #* emer_angles

# Plot
#plt.plot(df_30_sel.theta_deg, weighted_flux_30,
 #        linestyle='--', label='X-ray 30 km', color='green', linewidth=2)

# Seleziona solo le righe con theta_deg "esattamente interi" da 0 a 35



# Calcola flusso
#flux_20 = compute_overall_flux(df_20_sel)

# Moltiplica per emer_angles
#weighted_flux_20 = flux_20.to_numpy() #* emer_angles

# Plot
#plt.plot(df_20_sel.theta_deg, weighted_flux_20,
#         linestyle='--', label='X-ray 20 km', color='darkorange', linewidth=2)





# Calcola flusso
#flux_10 = compute_overall_flux(df_10_sel)

# Moltiplica per emer_angles
#weighted_flux_10 = flux_10.to_numpy()# * emer_angles

# Plot
#plt.plot(df_10_sel.theta_deg, weighted_flux_10,
 #        linestyle='--', label='X-ray 10 km', color='royalblue', linewidth=2)




plt.plot(df_30_above.theta_deg, compute_overall_flux(df_30_above),  linestyle='--', label='X-ray 30 km', color='green', linewidth=2)

plt.plot(df_20_above.theta_deg, compute_overall_flux(df_20_above),  linestyle='--', label='X-ray 20 km', color='darkorange', linewidth=2)

plt.plot(df_10_above.theta_deg, compute_overall_flux(df_10_above),  linestyle='--', label='X-ray 10 km', color='royalblue', linewidth=2)

# Plot
#plt.figure(figsize=(10, 6))

#plt.plot(df_10_above.theta_deg, flux_10, linestyle='--', label='Xray emission 10 km', color='royalblue',linewidth=3)

#plt.plot(df_20_above.theta_deg, flux_20, linestyle='--', label='Xray emission 20 km', color='darkorange',linewidth=3)
ax.tick_params(axis='both', labelsize=20); ax.locator_params(nbins=15)
#plt.plot(df_30_above.theta_deg, flux_30, linestyle='--',label='Xray emission 30 km', color='green',linewidth=3)

plt.xlabel('Viewing angle θ (degrees)',fontsize=20)
plt.ylabel('Flux (photons/m²)',fontsize=20)
#plt.title('Overall X-ray flux vs Viewing Angle at Different Altitudes (Below the limb)')
#plt.legend(fontsize=14)

plt.grid(False)
plt.yscale('log')
plt.xlim(40,88)
plt.ylim(1e-1,1e9)
plt.tight_layout()
plt.tight_layout(rect=[0, 0, 0.9, 1.])


ax2 = ax.twinx()

# === Emergence angles (già presenti nel tuo codice) ===
emer_angles_cut = emer_angles[:len(sorted_angles)]  # Troncati alla stessa lunghezza
emer_scaled = np.array(emer_angles_cut) 

# === Plot della curva di emergence sull'asse destro ===
ax2.plot(sorted_angles, emer_scaled,
         linestyle='-', color='Gray',
         label='Emergence', linewidth=3)

# === Asse y destro in log scale con etichette scientifiche ===
ax2.set_yscale('log')
ax2.set_ylabel('Emergence probability', fontsize=20, color='black')
ax2.tick_params(axis='y', labelcolor='black', labelsize=20)

# === Etichette asse y destro in potenze di 10 ===
import matplotlib.ticker as ticker

def sci_notation(x, _):
    if x == 0:
        return "0"
    exp = int(np.floor(np.log10(x)))
    return f"$10^{{{exp}}}$"

ax2.yaxis.set_major_formatter(ticker.FuncFormatter(sci_notation))
plt.show()

#overall_flux = (df_36_above.band0_rx + df_36_above.band1_rx + df_36_above.band2_rx) / df_36_above.area0_m2


